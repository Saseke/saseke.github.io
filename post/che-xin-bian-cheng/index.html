<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Smy</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="A student who is constantly striving"/>
<meta name="keywords" content="A student who is constantly striving"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://saseke.github.io/favicon.ico">

<link rel="stylesheet" href="https://saseke.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://saseke.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://saseke.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://saseke.github.io/images/avatar.png" alt="Smy"
                 class="img-responsive">
        </figure>
        <a href="https://saseke.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>Smy</h2>
        <p>A student who is constantly striving</p>
        <ul class="fh5co-social">
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://saseke.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://saseke.github.io/tag/ugAnwOalE/">paper</a></li>
                
                    <li><a href="https://saseke.github.io/tag/algorithm/">algorithm</a></li>
                
                    <li><a href="https://saseke.github.io/tag/diary/">diary</a></li>
                
                    <li><a href="https://saseke.github.io/tag/AwsgcjQkK/">c++</a></li>
                
                    <li><a href="https://saseke.github.io/tag/lbnI2Wnls/">distributed</a></li>
                
                    <li><a href="https://saseke.github.io/tag/tZS19L4dr/">file system</a></li>
                
                    <li><a href="https://saseke.github.io/tag/vT5ZzxYvS/">redis</a></li>
                
                    <li><a href="https://saseke.github.io/tag/JEV3JRwPx/">architecture</a></li>
                
                    <li><a href="https://saseke.github.io/tag/mgPa4qhSL/">storm</a></li>
                
                    <li><a href="https://saseke.github.io/tag/rVd9T6I6y/">hbase</a></li>
                
                    <li><a href="https://saseke.github.io/tag/RnNn2Kd83/">hive</a></li>
                
                    <li><a href="https://saseke.github.io/tag/eExHX0970/">leetcode</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            HomePage
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            Archive
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            Tag
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            About
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://saseke.github.io">Smy </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
                    <img src="https://saseke.github.io/post-images/che-xin-bian-cheng.png" alt="C++核心编程" class="img-responsive">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
                    <div class="tag-container">
                        
                            <a href="https://saseke.github.io/tag/AwsgcjQkK/" class="tag">c++, </a>
                        
                    </div>
                
            </span>
            <h2 class="fh5co-article-title animate-box">C++核心编程</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2022-05-18</li>
                <li>3838字</li>
                <li>17 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <h1 id="1-内存模型">1. 内存模型</h1>
<ul>
<li>代码区：存放函数体的二进制区域，由OS统一管理</li>
<li>全局区：存放<strong>全局变量</strong>或者<strong>静态变量</strong></li>
<li>栈区：由编译器自动分配和释放，存放函数的参数，局部变量</li>
<li>堆区：由程序员分配和释放，若程序员不是放，最后由OS进行释放</li>
</ul>
<h1 id="2-变量">2. 变量</h1>
<ul>
<li>
<p>全局变量</p>
<pre><code class="language-c++">int a = 10; // 全局变量
void test(){...}
</code></pre>
</li>
<li>
<p>静态变量</p>
<pre><code class="language-c++">void test(){
  static int a = 10; // 静态变量
}
</code></pre>
</li>
<li>
<p>普通变量</p>
<pre><code class="language-c++">void test(){
  int a = 10;
}
</code></pre>
</li>
<li>
<p>字符串常量</p>
</li>
</ul>
<h1 id="3-堆">3. 堆</h1>
<p>堆区域的数据，程序员可以使用<code>new</code>and <code>delete</code>进行管理</p>
<p><strong>单个元素</strong></p>
<pre><code class="language-c++">int *a = new int(10); // 分配单个元素内存空间
delete a.  //释放单个内存空间
</code></pre>
<p>​	<strong>数组</strong></p>
<pre><code class="language-c++">int *arr = new int[10];  // 分配数组
delete [] arr; // 释放数组内存空间
</code></pre>
<h1 id="4引用">4.引用</h1>
<p>本质：为数据类型起别名</p>
<pre><code class="language-c++">int a = 10;
int &amp;b = a;  // 为变量a起一个别名b,两者操作的是同一块内存空间
</code></pre>
<p>注意：</p>
<ol>
<li>引用必须进行初始化</li>
<li>引用一旦初始化，不能够改变</li>
</ol>
<p>引用在函数中的使用</p>
<pre><code class="language-c++">void swap(int &amp;a,int &amp;b){
  int tmp = a;
  a = b;
  b = tmp;
}
</code></pre>
<p><strong>引用本质：是一个指针常量，引用一旦初始化，指向的内存地址不能再发生变化</strong></p>
<p>常量引用：<strong>用来修饰形参，防止误操作</strong></p>
<h1 id="5-方法增强">5. 方法增强</h1>
<p><strong>5.1.设置方法的默认值</strong></p>
<p>形参设置默认值,在传递参数时可以不进行设置，<strong>但是默认的形参只能放在函数的申明最后边</strong></p>
<pre><code class="language-c++">int add(int a, int b = 10, int c = 20) {
    return a + b + c;
}
int main() {
    int sum = add(10,30);
    cout &lt;&lt; sum &lt;&lt; endl;
}

</code></pre>
<p><font color='red'>在函数申明时配置了参数，在函数实现的时候，就不能定义默认参数</font></p>
<p><strong>5.2.函数设置占位符</strong></p>
<pre><code class="language-c++">int swap(int a,int){ // 只定义数据类型，不定义对应的标识符，则就是占位符,在调用的时候，必须传入
}
</code></pre>
<h1 id="6-类和对象">6. 类和对象</h1>
<h2 id="61-访问权限">6.1 访问权限</h2>
<ol>
<li>public</li>
<li>protected</li>
<li>private</li>
</ol>
<h2 id="62-struct与class区别">6.2 struct与class区别</h2>
<p>struct默认属性的访问权限：公共</p>
<p>class默认属性的访问权限为：私有</p>
<h1 id="63-对象的初始化和清理">6.3 对象的初始化和清理</h1>
<h3 id="631-构造函数和析构函数">6.3.1 构造函数和析构函数</h3>
<ul>
<li>构造函数：主要用于在创建对象的时候，为成员变量进行复制操作</li>
<li>析构函数：用于对象销毁之前被调用，主要做一些对象销毁的工作</li>
</ul>
<p><strong>构造函数和析构函数不需要我们自己调用，编译器会主动为我们调用</strong></p>
<h2 id="632-构造函数和析构函数语法">6.3.2 构造函数和析构函数语法</h2>
<ul>
<li>构造函数：<code>类名(){}</code></li>
<li>析构函数: <code>~类名(){}</code></li>
</ul>
<pre><code class="language-c++">Cube() {
   cout &lt;&lt; &quot;构造函数被调用&quot; &lt;&lt; endl;
}

~Cube() {
   cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl;
}
</code></pre>
<h3 id="6321-构造方法分类">6.3.2.1 构造方法分类</h3>
<ul>
<li>
<p>括号法</p>
<ul>
<li>
<p>默认构造</p>
<pre><code class="language-c++">Person(){...}
// 调用的时候
Person p1; // 切记别使用Person p();
</code></pre>
</li>
<li>
<p>有参数构造</p>
<pre><code class="language-c++">Person(int a){...}
// 调用的时候
Person p2(10); 
</code></pre>
</li>
<li>
<p>拷贝构造</p>
<pre><code class="language-c++">Person(const Person &amp;a){...}
// 调用的时候
Person p3(p2);
</code></pre>
</li>
</ul>
</li>
<li>
<p>显示法</p>
<ul>
<li>Person p1; // 无参数</li>
<li>Person p2 = Person(10).;  // 有参数</li>
<li>Person p3 = Person(p1);  // 拷贝构造</li>
<li>Person(10);  // 匿名</li>
</ul>
</li>
</ul>
<h3 id="6323-析构函数使用场景">6.3.2.3 析构函数使用场景</h3>
<ul>
<li>使用一个已经初始化完成的对象去初始化另外一个对象</li>
<li>值传递的方法传递给方法的形式参数</li>
<li>以值传递的方式，返回局部对象</li>
</ul>
<h3 id="6324-构造函数调用规则">6.3.2.4 构造函数调用规则</h3>
<p>默认情况，c++会创建默认的无参构造函数，析构函数，拷贝构造函数。</p>
<p>构造函数的调用规则：</p>
<ol>
<li>如果用户自己定义了有参数的构造函数，c++不再提供默认的无参构造函数，但是会提供拷贝构造</li>
<li>如果自定义了拷贝构造函数，则c++不会提供其他构造函数</li>
</ol>
<h3 id="6325-浅拷贝与深拷贝">6.3.2.5 浅拷贝与深拷贝</h3>
<p>浅拷贝：所有东西都是采用<code>=</code>进行直接赋值操作</p>
<p>深拷贝：对需要在堆内存中分配内存的，在堆中分配新的内存空间</p>
<p><strong>浅拷贝</strong></p>
<pre><code class="language-c++">class Person {
private:
    int age;
    int *height;
public:
    Person(const int &amp;age) {
        this-&gt;age = age;
        height = new int(10);
    }

    ~Person() {
        delete height;
        cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl;
    }
};

int main() {
    Person p1(1);
    Person p2(p1);
}
</code></pre>
<p>上边这样操作，会导致p2在进行回收内存时报错：</p>
<pre><code class="language-c++">析构函数被调用
hello(6719,0x1147985c0) malloc: *** error for object 0x7ff6ca402b30: pointer being freed was not allocated
hello(6719,0x1147985c0) malloc: *** set a breakpoint in malloc_error_break to debug
</code></pre>
<p><strong>深拷贝</strong></p>
<pre><code class="language-c++">class Person {
private:
    int age;
    int *height;
public:
    Person(const int &amp;age) {
        this-&gt;age = age;
        height = new int(10);
    }

    ~Person() {
        delete height;  // 析构函数通常用来释放掉分配的堆内存空间
        cout &lt;&lt; &quot;析构函数被调用&quot; &lt;&lt; endl;
    }

    Person(const Person &amp;p) {
        age = p.age;
        height = new int(*p.height);  // 在拷贝构造函数中，分配新的内存空间
    }
};

int main() {
    Person p1(1);
    Person p2(p1);
}
</code></pre>
<p><font color='red'>如果有属性在堆上开辟内存空间时，一定要重新定义拷贝构造函数和析构函数，防止浅拷贝带来问题</font></p>
<h3 id="6326-初始化列表">6.3.2.6 初始化列表</h3>
<p>c++提供了另外一种初始化类属性的方法</p>
<p><code>构造函数():属性1（属性值1),属性2（属性2)...{}</code></p>
<pre><code class="language-c++">class Person {
private:
    string name;
    int age;
public:
    Person(const string &amp;name, const int &amp;age) : name(name), age(age) {

    }

    void print() {
        cout &lt;&lt; &quot;person name:&quot; &lt;&lt; name &lt;&lt; &quot; , person age:&quot; &lt;&lt; age &lt;&lt; endl;
    }
};
</code></pre>
<h3 id="6327-类对象作为类的成员">6.3.2.7 类对象作为类的成员</h3>
<pre><code class="language-c++">class Phone {

public:
    Phone(const string &amp;name) : phoneName(name) {
        cout &lt;&lt; &quot;phone的构造函数&quot; &lt;&lt; endl;
    }

    ~Phone() {
        cout &lt;&lt; &quot;Phone对象被销毁&quot; &lt;&lt; endl;
    }

    string phoneName;
};

class Person {

public:
    Person(const string &amp;name, const string &amp;phoneName) : name(name), phone(phoneName) {
        cout &lt;&lt; &quot;person的构造函数&quot; &lt;&lt; endl;
    }

    ~Person() {
        cout &lt;&lt; &quot;Person的析构函数被销毁&quot; &lt;&lt; endl;
    }

    string name;
    Phone phone;
};
</code></pre>
<p>构造函数执行的顺序，与析构函数执行的顺序是相反的。</p>
<h3 id="6328-静态成员变量与静态成员函数">6.3.2.8 静态成员变量与静态成员函数</h3>
<ul>
<li>
<p>静态成员变量</p>
<ul>
<li>
<p>在编译阶段分配内存</p>
</li>
<li>
<p><font color='red'>在类内申明，类外初始化</font></p>
<pre><code class="language-c++">class Person {

public:
    static string id;
};

string  Person::id = &quot;hello&quot;;
</code></pre>
</li>
<li>
<p>所有对象共享一份数据</p>
</li>
</ul>
</li>
<li>
<p>静态成员的访问方式</p>
<ul>
<li>
<p>通过对象进行访问</p>
<pre><code class="language-c++">Person p();
p.id
</code></pre>
</li>
<li>
<p>通过类名进行访问</p>
<pre><code class="language-c++">Person::id
</code></pre>
</li>
</ul>
</li>
<li>
<p>静态成员函数</p>
<ul>
<li>所有的对象共享一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><font color='red'>空对象也占用内存空间，每一个空对象占用1个字节的内存空间</font></p>
<h2 id="64-c对象模型与this指针">6.4 C++对象模型与this指针</h2>
<h3 id="641-成员变量和成员函数分开存储">6.4.1 成员变量和成员函数分开存储</h3>
<p><strong>只有成员变量占用对象的内存空间，成员函数，静态成员变量，静态成员函数都不占用对象空间。（多个对象共享一份）</strong></p>
<h3 id="642-const修饰成员函数">6.4.2 const修饰成员函数</h3>
<p><strong>常函数</strong></p>
<ul>
<li>成员函数后加<code>const</code>关键字，我们称这个函数是常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性前面加上<code>mutable</code>后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象</strong></p>
<ul>
<li>声明对象前面加<code>const</code>关键字</li>
<li>常对象只能调用常函数</li>
</ul>
<h2 id="65-友元">6.5 友元</h2>
<p>友元作用：提供访问对象的私有属性</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h3 id="651-全局函数做友元">6.5.1 全局函数做友元</h3>
<p>需要在类的第一行添加对应的全局函数的申明，并且标示<code>friend</code>关键字</p>
<pre><code class="language-c++">class Person {
    friend void print(const Person &amp;person);

private:
    string phone;
public:
    static string id;
    string username;
    string password;
    int age;

    Person(const string &amp;name, const string &amp;pwd, const int age) : username(name), password(pwd), age(age) {}

    Person() {
        this-&gt;username = &quot;yoke&quot;;
        this-&gt;password = &quot;123456&quot;;
        this-&gt;age = 10;
        this-&gt;phone = &quot;1593512&quot;;
    }

    ~Person() {}

};

string  Person::id = &quot;fjksdfjsdk&quot;;

void print(const Person &amp;person) {
    cout &lt;&lt; &quot;用户名字:&quot; &lt;&lt; person.username &lt;&lt; &quot;,用户id:&quot; &lt;&lt; Person::id &lt;&lt; &quot;用户phone:&quot; &lt;&lt; person.phone &lt;&lt; endl;
}
</code></pre>
<h3 id="652-类做友元">6.5.2 类做友元</h3>
<p>在类内部申明friend类</p>
<pre><code class="language-c++">class Food {
    friend class Person;

private:
    string food;
public:
};

class Person {
private:
    Food food;
public:
    void setFood(const string &amp;foodName) {
        food.food = foodName;
    }
};

int main() {
    Person p;
    p.setFood(&quot;dumpling.&quot;);
}
</code></pre>
<h3 id="653-成员函数做友元">6.5.3 成员函数做友元</h3>
<pre><code class="language-c++">class Food;

class Person {
public:
    Person();

    Food *food;

    void visit1() const; // 只想让该方法可以访问Food.name

};

class Food {
    friend void Person::visit1() const;

private:
    string name;
public:
    Food();
};

// 类外实现成员函数


void Person::visit1() const {
    cout &lt;&lt; food-&gt;name &lt;&lt; endl;
}

Person::Person() {
    food = new Food;
}

Food::Food() {
    name = &quot;dumpling&quot;;
}
</code></pre>
<h2 id="64-运算符重载">6.4 运算符重载</h2>
<p>对已有的运算符进行重新定义，赋予其另外一种功能，以适应不同的数据类型。</p>
<p>常用的：加号重载，左移，递增，赋值，关系，函数调用运算符重载</p>
<h3 id="641-加号运算符重载">6.4.1 加号运算符重载</h3>
<p>就是一个进行对象相加的函数，只不过方法名称叫做<code>operator+</code></p>
<pre><code class="language-c++">class Person {
private:
    int age;
public:
    explicit Person(const int &amp;age);

    Person operator+(const Person &amp;person) const;

    void print();
};

Person::Person(const int &amp;age) {
    this-&gt;age = age;
}

Person Person::operator+(const Person &amp;person) const {
    return Person(this-&gt;age + person.age);
}

void Person::print() {
    cout &lt;&lt; this-&gt;age &lt;&lt; endl;

}

int main() {
    Person p1(10);
    Person p2(11);
    Person p3 = p1 + p2;
    p3.print();
}
</code></pre>
<h3 id="642-左移运算符重载">6.4.2 左移运算符重载</h3>
<p><font color='red'>左移运算符不能通过成员函数去进行重载</font></p>
<p>功能：重载左移运算符可以配合友元可以实现输出自定义数据类型</p>
<pre><code class="language-c++">class Person {
    friend ostream &amp;operator&lt;&lt;(ostream &amp;cout, Person &amp;p);

private:
    int age;
public:
    explicit Person(const int &amp;age);

    Person operator+(const Person &amp;person) const;

    void print();

};

Person::Person(const int &amp;age) {
    this-&gt;age = age;
}

Person Person::operator+(const Person &amp;person) const {
    return Person(this-&gt;age + person.age);
}

void Person::print() {
    cout &lt;&lt; this-&gt;age &lt;&lt; endl;

}


ostream &amp;operator&lt;&lt;(ostream &amp;cout, Person &amp;p) {
    cout &lt;&lt; p.age;
    return cout;
}

int main() {
    Person p1(10);
    cout &lt;&lt; p1;
}
</code></pre>
<h3 id="643-递增运算符重载">6.4.3 递增运算符重载</h3>
<p>需要注意前置与后置在定义时的区别</p>
<ul>
<li>前置</li>
</ul>
<pre><code class="language-c++">  // ++ 前置运算符重载
    Person &amp;operator++() {
        this-&gt;age++;
        return *this;
    }
</code></pre>
<ul>
<li>
<p>后置</p>
<p><font color='red'>后置返回的只能是值，不能返回引用</font></p>
</li>
</ul>
<pre><code class="language-c++">  // 后置运算符重载
    Person operator++(int) {
        Person tmp = *this;
        age++;
        return tmp;
    }
</code></pre>
<p>后置相较于前置多了一个占位参数</p>
<h3 id="644-赋值运算符重载">6.4.4 赋值运算符重载</h3>
<p>赋值运算符重载通常用在属性copy需要进行深拷贝的情况</p>
<pre><code class="language-c++"> Person &amp;operator=(Person &amp;p1) {
        if (p_age != nullptr) {
            delete p_age;
        }
        p_age = new int(*p1.p_age);
        return *this;
}
</code></pre>
<h3 id="645-关系运算符">6.4.5 关系运算符</h3>
<ul>
<li><strong>==</strong></li>
</ul>
<pre><code class="language-c++">class Person {
private:
    string name;


public:
    Person(const string &amp;name) : name(name) {}

    bool operator==(Person &amp;p1) {
        return name == p1.name;
    }
};


int main() {
    Person p1(&quot;yoke&quot;);
    Person p2(&quot;yoke&quot;);
    bool flag = p1 == p2;
    cout &lt;&lt; flag &lt;&lt; endl;
}
</code></pre>
<h3 id="646-函数运算符">6.4.6 函数运算符</h3>
<p>() 函数调用运算符重载.别名：伪函数</p>
<pre><code class="language-c++">class CPrint {
public:
    void operator()(const string &amp;text) {
        cout &lt;&lt; text &lt;&lt; endl;
    }
};

int main() {
    CPrint print;
    print(&quot;hello world&quot;);
}
</code></pre>
<h1 id="7-继承">7. 继承</h1>
<h2 id="71-继承的基本语法">7.1 继承的基本语法</h2>
<pre><code class="language-c++">class name : 继承方式 xxx{
  
}
</code></pre>
<pre><code class="language-c++">class Base {
public:
    void insert() {
        cout &lt;&lt; &quot;插入数据&quot; &lt;&lt; endl;
    }
};

class DBOperator : public Base {
public:
    void deleteData() {
        cout &lt;&lt; &quot;删除数据&quot; &lt;&lt; endl;
    }
};

</code></pre>
<h2 id="72-继承方式">7.2 继承方式</h2>
<p>public,protected,private继承三种继承方式</p>
<ul>
<li>
<p>public继承方式</p>
<p>子类针对父亲的public方法，还是public权限</p>
</li>
<li>
<p>protected</p>
<p>子类对于父亲的public方法，权限变成了protected</p>
</li>
<li>
<p>private</p>
<p>子类对于父亲的public方法，权限变成了private</p>
</li>
</ul>
<p><strong>父类中所有非静态成员属性都会被子类继承下去。父类中的私有属性，是被编译器给隐藏了，因此是访问不到的，但是确实被继承了下去</strong></p>
<h2 id="73-继承中构造和析构的顺序">7.3 继承中构造和析构的顺序</h2>
<p>构造函数的顺序与析构函数的顺序是相反的</p>
<h2 id="74-继承同名成员处理方式">7.4 继承同名成员处理方式</h2>
<p>如果通过子类对象，想要访问父类中的同名称对象，需要添加一点申明</p>
<pre><code class="language-c++">childer.Parent::m_num
</code></pre>
<pre><code class="language-c++">class Base {
public:
    int m_num = 100;

    void test() {
        cout &lt;&lt; &quot;parent方法&quot; &lt;&lt; endl;
    }
};

class DBOperator : public Base {
public:
    int m_num = 200;

    void test() {
        cout &lt;&lt; &quot;children method&quot; &lt;&lt; endl;
    }
};

int main() {
    DBOperator dbOperator;
    // 访问子类的m_num属性
    cout&lt;&lt;dbOperator.m_num&lt;&lt;endl;
    // 访问弗雷德m_num属性
    cout&lt;&lt;dbOperator.Base::m_num&lt;&lt;endl;
    // 访问子类的test方法
    dbOperator.test();
    // 访问父类的test方法
    dbOperator.Base::test();
}
</code></pre>
<p><strong>如果子类中出现和父类同名的成员函数，子类中的同名成员会隐藏掉父类所有的同名成员函数，如果想要访问到父类的被隐藏掉的同名成员函数，需要加作用域</strong></p>
<h2 id="75-继承同名静态成员处理方式">7.5 继承同名静态成员处理方式</h2>
<p>与继承同名成员处理方式一致</p>
<h2 id="76-多继承">7.6 多继承</h2>
<p>语法: class 子类 : 继承方式 父类1,继承方式 父类2</p>
<p>在c++开发中不太推荐使用多继承</p>
<p><strong>多继承存在菱形继承问题，可通过使用虚基类，虚继承方式来解决</strong></p>
<h1 id="8-多态">8 多态</h1>
<p>多态分为静态多态和动态多态。</p>
<ul>
<li>静态多态：方法的重载</li>
<li>动态多态：父类引用指向子类实例</li>
</ul>
<p>动态多态的使用：</p>
<ol>
<li>有继承关系</li>
<li>子类重写父类的virtual函数</li>
</ol>
<pre><code class="language-c++">class Animal {
public:
    virtual void speak() {
        cout &lt;&lt; &quot;动物叫&quot; &lt;&lt; endl;
    }
};

class Cat : public Animal {
public:
    void speak() {
        cout &lt;&lt; &quot;猫叫&quot; &lt;&lt; endl;
    }
};

void test(Animal &amp;animal) {
    animal.speak();
}

int main() {
    Cat cat;
    test(cat);
    return 1;
}
</code></pre>
<h2 id="81-纯虚函数和抽象类">8.1 纯虚函数和抽象类</h2>
<p>在多态中，通常父类的虚函数的实现是没有意义的，主要都是调用子类的重写的内容。因此可以将虚函数改为纯虚函数。</p>
<p>纯虚函数语法: <code>virtual 返回值类型 函数名(参数列表)=0</code></p>
<p>当类中有了纯虚函数，该类叫做抽象类</p>
<p><strong>抽象类特点</strong></p>
<ul>
<li>抽象类不能被实例化</li>
<li>子类必须实现抽象类中的纯虚函数，否则还是抽象类</li>
</ul>
<pre><code class="language-c++">class Base {
public:
    int num;

    virtual int getResult() = 0;
};

class Children : public Base {
public:
    int getResult() override {
        return 1;
    }
};

int main() {
    Children children;
    cout &lt;&lt; children.getResult() &lt;&lt; endl;
}
</code></pre>
<h2 id="82-虚析构函数和纯虚析构函数">8.2 虚析构函数和纯虚析构函数</h2>
<p>共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要具体的函数实现</li>
</ul>
<p>虚析构与纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<ol>
<li>虚析构语法</li>
</ol>
<pre><code class="language-c++">virtual ~类名(){}
</code></pre>
<pre><code class="language-c++">class Animal {
public:
    virtual void shouting() = 0;

    Animal() {
        cout &lt;&lt; &quot;animal构造函数被调用&quot; &lt;&lt; endl;
    }

    virtual ~Animal() {
        cout &lt;&lt; &quot;animal的析构函数被调用&quot; &lt;&lt; endl;
    }
};

class Cat : public Animal {
public:
    string *name;

    Cat(const string &amp;name) {
        cout &lt;&lt; &quot;cat构造函数被调用&quot; &lt;&lt; endl;
        this-&gt;name = new string(name);
    }

    ~Cat() {
        if (name != NULL) {
            delete name;
            name = NULL;
        }
        cout &lt;&lt; &quot;cat析构函数被调用&quot; &lt;&lt; endl;
    }

    void shouting() override {
        cout &lt;&lt; this-&gt;name &lt;&lt; &quot;在叫&quot; &lt;&lt; endl;
    }
};

int main() {
    Animal *animal = new Cat(&quot;tom&quot;);
    animal-&gt;shouting();
    delete animal;
}
</code></pre>
<ol start="2">
<li>纯虚析构语法</li>
</ol>
<pre><code class="language-c++">virtual ~类名()=0;
类名::~类名(){}
</code></pre>
<pre><code class="language-c++">class Animal {
public:
    virtual void shouting() = 0;

    Animal() {
        cout &lt;&lt; &quot;animal构造函数被调用&quot; &lt;&lt; endl;
    }

    virtual ~Animal() = 0;
};

Animal::~Animal() {
    cout &lt;&lt; &quot;animal的析构函数被调用&quot; &lt;&lt; endl;
}

class Cat : public Animal {
public:
    string *name;

    Cat(const string &amp;name) {
        cout &lt;&lt; &quot;cat构造函数被调用&quot; &lt;&lt; endl;
        this-&gt;name = new string(name);
    }

    ~Cat() {
        if (name != nullptr) {
            delete name;
            name = nullptr;
        }
        cout &lt;&lt; &quot;cat析构函数被调用&quot; &lt;&lt; endl;
    }

    void shouting() override {
        cout &lt;&lt; this-&gt;name &lt;&lt; &quot;在叫&quot; &lt;&lt; endl;
    }
};

int main() {
    Animal *animal = new Cat(&quot;tom&quot;);
    animal-&gt;shouting();
    delete animal;
}
</code></pre>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://saseke.github.io/post/diary-2022-5-11/">
                                    <h3 class="post-title">
                                        Diary-2022-5-11
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li><a href="#1-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B">1. 内存模型</a></li>
<li><a href="#2-%E5%8F%98%E9%87%8F">2. 变量</a></li>
<li><a href="#3-%E5%A0%86">3. 堆</a></li>
<li><a href="#4%E5%BC%95%E7%94%A8">4.引用</a></li>
<li><a href="#5-%E6%96%B9%E6%B3%95%E5%A2%9E%E5%BC%BA">5. 方法增强</a></li>
<li><a href="#6-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1">6. 类和对象</a>
<ul>
<li><a href="#61-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">6.1 访问权限</a></li>
<li><a href="#62-struct%E4%B8%8Eclass%E5%8C%BA%E5%88%AB">6.2 struct与class区别</a></li>
</ul>
</li>
<li><a href="#63-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86">6.3 对象的初始化和清理</a><br>
*
<ul>
<li><a href="#631-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">6.3.1 构造函数和析构函数</a></li>
<li><a href="#632-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95">6.3.2 构造函数和析构函数语法</a>
<ul>
<li><a href="#6321-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB">6.3.2.1 构造方法分类</a></li>
<li><a href="#6323-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">6.3.2.3 析构函数使用场景</a></li>
<li><a href="#6324-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99">6.3.2.4 构造函数调用规则</a></li>
<li><a href="#6325-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D">6.3.2.5 浅拷贝与深拷贝</a></li>
<li><a href="#6326-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">6.3.2.6 初始化列表</a></li>
<li><a href="#6327-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">6.3.2.7 类对象作为类的成员</a></li>
<li><a href="#6328-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">6.3.2.8 静态成员变量与静态成员函数</a></li>
</ul>
</li>
<li><a href="#64-c%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E4%B8%8Ethis%E6%8C%87%E9%92%88">6.4 C++对象模型与this指针</a>
<ul>
<li><a href="#641-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%86%E5%BC%80%E5%AD%98%E5%82%A8">6.4.1 成员变量和成员函数分开存储</a></li>
<li><a href="#642-const%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">6.4.2 const修饰成员函数</a></li>
</ul>
</li>
<li><a href="#65-%E5%8F%8B%E5%85%83">6.5 友元</a>
<ul>
<li><a href="#651-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83">6.5.1 全局函数做友元</a></li>
<li><a href="#652-%E7%B1%BB%E5%81%9A%E5%8F%8B%E5%85%83">6.5.2 类做友元</a></li>
<li><a href="#653-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%81%9A%E5%8F%8B%E5%85%83">6.5.3 成员函数做友元</a></li>
</ul>
</li>
<li><a href="#64-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">6.4 运算符重载</a>
<ul>
<li><a href="#641-%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">6.4.1 加号运算符重载</a></li>
<li><a href="#642-%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">6.4.2 左移运算符重载</a></li>
<li><a href="#643-%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">6.4.3 递增运算符重载</a></li>
<li><a href="#644-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD">6.4.4 赋值运算符重载</a></li>
<li><a href="#645-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6">6.4.5 关系运算符</a></li>
<li><a href="#646-%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6">6.4.6 函数运算符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-%E7%BB%A7%E6%89%BF">7. 继承</a>
<ul>
<li><a href="#71-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">7.1 继承的基本语法</a></li>
<li><a href="#72-%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">7.2 继承方式</a></li>
<li><a href="#73-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E7%9A%84%E9%A1%BA%E5%BA%8F">7.3 继承中构造和析构的顺序</a></li>
<li><a href="#74-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">7.4 继承同名成员处理方式</a></li>
<li><a href="#75-%E7%BB%A7%E6%89%BF%E5%90%8C%E5%90%8D%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F">7.5 继承同名静态成员处理方式</a></li>
<li><a href="#76-%E5%A4%9A%E7%BB%A7%E6%89%BF">7.6 多继承</a></li>
</ul>
</li>
<li><a href="#8-%E5%A4%9A%E6%80%81">8 多态</a>
<ul>
<li><a href="#81-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">8.1 纯虚函数和抽象类</a></li>
<li><a href="#82-%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">8.2 虚析构函数和纯虚析构函数</a></li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></p>
</footer>


    <!-- jQuery -->
<script src="https://saseke.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://saseke.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://saseke.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://saseke.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://saseke.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://saseke.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://saseke.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
</script>




</body>
</html>
