<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Smy</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<meta name="description" content="A student who is constantly striving"/>
<meta name="keywords" content="A student who is constantly striving"/>

<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
<link rel="shortcut icon" href="https://saseke.github.io/favicon.ico">

<link rel="stylesheet" href="https://saseke.github.io/styles/main.css">

<!-- Modernizr JS -->
<script src="https://saseke.github.io/media/scripts/modernizr-2.6.2.min.js"></script>
<!-- FOR IE9 below -->
<!--[if lt IE 9]>
<scripts src="https://saseke.github.io/media/scripts/respond.min.js"></scripts>
<![endif]-->

<!-- Comment -->



<!-- katex -->
<!--<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet">-->

<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">



</head>
<body>
    <div id="fh5co-offcanvas">
    <a href="#!" class="fh5co-close-offcanvas js-fh5co-close-offcanvas">
        <span><i class="icon-cross3"></i> <span>Close</span></span>
    </a>
    <div class="fh5co-bio">
        <figure>
            <img src="https://saseke.github.io/images/avatar.png" alt="Smy"
                 class="img-responsive">
        </figure>
        <a href="https://saseke.github.io/post/about/"><h3 class="heading">ABOUT ME</h3></a>
        <h2>Smy</h2>
        <p>A student who is constantly striving</p>
        <ul class="fh5co-social">
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
                <li>
                    
                </li>
            
        </ul>
    </div>

    <div class="fh5co-menu">

        <!-- 标签 -->
        <div class="fh5co-box">
            <a href="https://saseke.github.io/tags/"><h3 class="heading">👉标签</h3></a>
            <ul>
                
                    <li><a href="https://saseke.github.io/tag/ugAnwOalE/">paper</a></li>
                
                    <li><a href="https://saseke.github.io/tag/algorithm/">algorithm</a></li>
                
                    <li><a href="https://saseke.github.io/tag/diary/">diary</a></li>
                
                    <li><a href="https://saseke.github.io/tag/AwsgcjQkK/">c++</a></li>
                
                    <li><a href="https://saseke.github.io/tag/lbnI2Wnls/">distributed</a></li>
                
                    <li><a href="https://saseke.github.io/tag/tZS19L4dr/">file system</a></li>
                
                    <li><a href="https://saseke.github.io/tag/vT5ZzxYvS/">redis</a></li>
                
                    <li><a href="https://saseke.github.io/tag/JEV3JRwPx/">architecture</a></li>
                
                    <li><a href="https://saseke.github.io/tag/mgPa4qhSL/">storm</a></li>
                
                    <li><a href="https://saseke.github.io/tag/rVd9T6I6y/">hbase</a></li>
                
                    <li><a href="https://saseke.github.io/tag/RnNn2Kd83/">hive</a></li>
                
                    <li><a href="https://saseke.github.io/tag/eExHX0970/">leetcode</a></li>
                
            </ul>
        </div>
    </div>
</div>

<header id="fh5co-header">
    <div class="container-fluid">
        <div class="row">
            <a href="#" class="js-fh5co-nav-toggle fh5co-nav-toggle"><i></i></a>
            <ul class="fh5co-social">
                
                    <li>
                        <a href="/"
                        
                        >
                            HomePage
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives"
                        
                        >
                            Archive
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags"
                        
                        >
                            Tag
                        </a>
                    </li>
                
                    <li>
                        <a href="/post/about"
                        
                        >
                            About
                        </a>
                    </li>
                
            </ul>
            <div class="col-lg-12 col-md-12 text-center">
                <h1 id="fh5co-logo">
                    <a href="https://saseke.github.io">Smy </a>
                </h1>
            </div>
        </div>
    </div>
</header>


    <!--  <a href="#" class="fh5co-post-prev"><span>👈 Prev</span></a>-->
    <!--  <a href="#" class="fh5co-post-next"><span>Next 👉</span></a>-->

    <!-- 等gridea出自定义页面功能再优化一下 -->
    
        <div class="container-fluid">
    <div class="row fh5co-post-entry single-entry">
        <article class="col-lg-8 col-lg-offset-2 col-md-8 col-md-offset-2 col-sm-8 col-sm-offset-2 col-xs-12 col-xs-offset-0">
            <figure class="animate-box">
                
                    <img src="https://saseke.github.io/post-images/cti-gao-bian-cheng.png" alt="c++提高编程" class="img-responsive">
                
            </figure>
            <span class="fh5co-meta animate-box">
                
                    <div class="tag-container">
                        
                            <a href="https://saseke.github.io/tag/AwsgcjQkK/" class="tag">c++, </a>
                        
                    </div>
                
            </span>
            <h2 class="fh5co-article-title animate-box">c++提高编程</h2>
            <ol class="breadcrumb fh5co-meta fh5co-date animate-box" style="margin-bottom:0; background-color:#f8f9fa">
                <li>2022-05-30</li>
                <li>5313字</li>
                <li>25 min read</li>
            </ol>

            <div class="col-lg-12 col-lg-offset-0 col-md-12 col-md-offset-0 col-sm-12 col-sm-offset-0 col-xs-12 col-xs-offset-0 text-left content-article">
                <div class="row">
                    <div class="col-md-12 animate-box post-content">
                        <p> <h1 id="1-模板">1. 模板</h1>
<p><strong>特点:</strong></p>
<ol>
<li>模版不能直接使用，它只是一个框架</li>
<li>模板不是万能的，具有一定的局限性</li>
</ol>
<h2 id="11-函数模板">1.1 函数模板</h2>
<h3 id="111模板定义">1.1.1模板定义</h3>
<p><strong>语法</strong></p>
<pre><code class="language-c++">template&lt;typename T&gt;  // 申明T变量，告诉编译器，下边我会使用T,不要报错
// 函数申明/定义
</code></pre>
<p><strong>解释</strong></p>
<ul>
<li>template: 申明创建模板</li>
<li>typename: 表明后边的符号是一种数据类型，可以使用class代替</li>
<li>T: 通用的数据类型，名字可以替换，但通常是大写字母</li>
</ul>
<p>模板调用</p>
<ol>
<li>自动类型推导</li>
</ol>
<pre><code class="language-c++">int a = 2,b = 3;
swap(a,b);  // 编译器自动推导类型为int
</code></pre>
<ol start="2">
<li>显示指定类型</li>
</ol>
<pre><code class="language-c++">int a = 2,b = 3;
swap&lt;int&gt;(a,b);
</code></pre>
<p>模板使用例子:</p>
<pre><code class="language-c++">// 模板定义
template&lt;typename T&gt;
// 数据交换
void mySwap(T &amp;t1, T &amp;t2) {
    T t3 = t1;
    t1 = t2;
    t2 = t3;
}

int main() {
    // 使用模板
    int a = 2, b = 3;
    mySwap(a, b);
    cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b=&quot; &lt;&lt; b &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="112-普通函数与函数模板区别">1.1.2 普通函数与函数模板区别</h3>
<ol>
<li>普通函数调用时候，可以发生隐式转换</li>
<li>函数模板，如果使用自动推导，不会发生隐式转换</li>
<li>函数模板使用显示申明类型的方式，可以发生隐式转换</li>
</ol>
<h3 id="113-普通函数与函数模板调用规则">1.1.3 普通函数与函数模板调用规则</h3>
<ol>
<li>如果普通函数与函数模板都可以调用，优先调用普通函数</li>
<li>如果想强制调用函数模板，可以使用空模板参数的方法强制调用函数模板</li>
</ol>
<pre><code class="language-c++">// 模板定义
template&lt;typename T&gt;
// 数据交换
void mySwap(T &amp;t1, T &amp;t2) {
    cout &lt;&lt; &quot;模板调用&quot; &lt;&lt; endl;
}

void mySwap(int a, int b) {
    cout &lt;&lt; &quot;简单函数调用&quot; &lt;&lt; endl;
}

int main() {
    int a = 1, b = 10;
    mySwap&lt;&gt;(a, b);
    return 0;
}
</code></pre>
<ol start="3">
<li>函数模板可以重载</li>
</ol>
<pre><code class="language-c++">// 模板定义
template&lt;typename T&gt;
// 数据交换
void mySwap(T &amp;t1, T &amp;t2) {
    cout &lt;&lt; &quot;模板调用&quot; &lt;&lt; endl;
}
// 模板重载
template&lt;typename T&gt;
void mySwap(T &amp;t1, T &amp;t2, T &amp;t3) {
    cout &lt;&lt; &quot;第二个函数模板被调用&quot; &lt;&lt; endl;
}
</code></pre>
<ol start="4">
<li>如果函数模板可以更好的匹配，优先调用模板</li>
</ol>
<pre><code class="language-c++">// 模板定义
template&lt;typename T&gt;
// 数据交换
void mySwap(T &amp;t1, T &amp;t2) {
    cout &lt;&lt; &quot;模板调用&quot; &lt;&lt; endl;
}
void mySwap(int a, int b) {
    cout &lt;&lt; &quot;简单函数调用&quot; &lt;&lt; endl;
}

int main() {
    char a = 'a', b = 'b';  
    mySwap(a, b);
    return 0;
}
</code></pre>
<p><strong>如果调用普通方法，需要将char类型的数据先转换成int类型，而模版函数却不需要，所以优先调用模板函数</strong></p>
<h3 id="114-模板的局限性">1.1.4 模板的局限性</h3>
<p>函数模板不是万能的。比如：判断两个数据是否相等。如果是传入两个自定义的数据类型就会发生错误。因此我们可以提供模板的重载去为<strong>特定的类型</strong>和<strong>具体的模板</strong></p>
<pre><code class="language-c++">// 判断两个数据是否相同
template&lt;typename T&gt;
int judge(T t1, T t2) {
    return t1 == t2;
}

class Person {
public:
    string name;
    int age;

    Person(const string &amp;name, int age) : name(name), age(age) {}
};

// 对模板函数进行扩充,对模版函数进行扩充，专门提供对人进行比较的函数
template&lt;&gt;
int judge(Person p1, Person p2) {
    return p1.age == p2.age &amp;&amp; p1.name == p2.name;
}
</code></pre>
<h2 id="12-类模版">1.2 类模版</h2>
<h3 id="121-类模版语法">1.2.1 类模版语法</h3>
<p><code>template&lt;typename xxx,typename xxx&gt;</code> 去申明，紧跟着写类的定义。这个就是类的模板</p>
<p><strong>类模板例子</strong></p>
<pre><code class="language-c++">template&lt;typename PersonName, typename PersonAge&gt;
class Person {
public:
    PersonName m_name;
    PersonAge m_age;

    Person(PersonName name, PersonAge age) : m_name(name), m_age(age) {}
};
int main() {
    Person&lt;string, int&gt; p(&quot;hello&quot;, 10);
    cout &lt;&lt; p.m_name &lt;&lt; &quot; &quot; &lt;&lt; p.m_age &lt;&lt; endl;
}
</code></pre>
<h3 id="122-类模板与函数模板区别">1.2.2 类模板与函数模板区别</h3>
<ol>
<li>类模板没有自动类型推导</li>
<li>类模板在模板参数中可以有默认参数。有了默认参数之后，就可以在指定参数类型的时候，不需要再指定</li>
</ol>
<pre><code class="language-c++">template&lt;typename PersonName, typename PersonAge=int&gt;  // 为PersonAge设置了默认的类型为int
class Person {
public:
    PersonName m_name;
    PersonAge m_age;

    Person(PersonName name, PersonAge age) : m_name(name), m_age(age) {}
};

int main() {
    Person&lt;string&gt; p(&quot;hello&quot;, 10);
    cout &lt;&lt; p.m_name &lt;&lt; &quot; &quot; &lt;&lt; p.m_age &lt;&lt; endl;
}
</code></pre>
<h3 id="123-类模板中成员函数创建时机">1.2.3 类模板中成员函数创建时机</h3>
<p>类模板中成员函数并不是一开始就创建的，而是在调用的时候创建。因此，对于T,调用t的任何方法，编译都会通过。但是：在运行的时候，就会报错。</p>
<pre><code class="language-c++">class Person1 {
public:
    void show1() {
        cout &lt;&lt; &quot;person 1 show&quot; &lt;&lt; endl;
    }
};

class Person2 {
public:
    void show2() {
        cout &lt;&lt; &quot;Person 2 show&quot; &lt;&lt; endl;
    }
};

template&lt;typename T&gt;
class AbstractPerson {
public:
    T p;

    void test1() {
        p.show1();
    }

    void test2() {
        p.show2();
    }
};

int main() {
    AbstractPerson&lt;Person1&gt; abstractPerson;
    abstractPerson.test1();
    abstractPerson.test2();
}
</code></pre>
<h3 id="124-类模板对象做函数参数">1.2.4 类模板对象做函数参数</h3>
<ol>
<li>指定传入的类型 - 直接显示对象的数据类型</li>
</ol>
<pre><code class="language-c++">void test1(Person&lt;string, int&gt; p) {
}
</code></pre>
<ol start="2">
<li>参数模板化 - 将对象中的参数变成模板进行传递</li>
</ol>
<pre><code class="language-c++">// 参数模板化
template&lt;typename T1, typename T2&gt;
void test2(Person&lt;T1, T2&gt; p) {

}
</code></pre>
<ol start="3">
<li>整个类模板化 - 将这个对象类型 模板化进行传递</li>
</ol>
<pre><code class="language-c++">template&lt;class T&gt;
void test3(T t) {

}
</code></pre>
<h3 id="125-类模板与继承">1.2.5 类模板与继承</h3>
<p>如果父类是类模板，那么子类必须指明父类中的T的类型</p>
<pre><code class="language-c++">template&lt;typename T&gt;
class Parent {
public:
    T m_name;
};

template&lt;typename U, typename T&gt;
class Child : public Parent&lt;T&gt; {
public:
    U m_age;

    void show() {
        cout &lt;&lt; &quot;m_name的数据类型:&quot; &lt;&lt; typeid(T).name() &lt;&lt; &quot; , m_age的数据类型:&quot; &lt;&lt; typeid(U).name() &lt;&lt; endl;
        cout &lt;&lt; &quot;m_name:&quot; &lt;&lt; this-&gt;m_name &lt;&lt; &quot; m_age:&quot; &lt;&lt; this-&gt;m_age &lt;&lt; endl;
    }
};
</code></pre>
<h3 id="126-类模板的成员函数的类外实现">1.2.6 类模板的成员函数的类外实现</h3>
<p>实现方式其实和普通类的类外成员函数类似，只不过加了template相关标示</p>
<pre><code class="language-c++">template&lt;class T1, class T2&gt;
class Person {
    T1 m_name;
    T2 m_age;

    Person(T1 name, T2 age) : m_name(name), m_age(age) {}

    void show();

    Person();
};

template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person() {
}

template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::show() {
}
</code></pre>
<h3 id="127-类模板文件分模块编写">1.2.7 类模板文件分模块编写</h3>
<p>如果常规分文件编写之后，会出现链接错误问题。解决方式有两种：</p>
<ol>
<li>直接包含.cpp文件，不在直接包含头文件</li>
<li>将模板定义和成员函数放在一个文件中，将后缀名改成<code>.hpp</code></li>
</ol>
<p><strong>Person.hpp</strong></p>
<pre><code class="language-c++">// 模板定义
using namespace std;

#include &quot;iostream&quot;

template&lt;class T1, class T2&gt;
class Person {
public:
    T1 m_name;
    T2 m_age;

    void show();

    Person();
};

// 模板的实现
template&lt;class T1, class T2&gt;
void Person&lt;T1, T2&gt;::show() {
    cout &lt;&lt; m_name &lt;&lt; &quot; , &quot; &lt;&lt; m_age &lt;&lt; endl;
}

template&lt;class T1, class T2&gt;
Person&lt;T1, T2&gt;::Person() {
    cout &lt;&lt; &quot;构造函数被调用&quot; &lt;&lt; endl;
}
</code></pre>
<p><strong>main.cpp</strong></p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &quot;Person.hpp&quot;

using namespace std;

int main() {
    Person&lt;string, int&gt; p;
    p.m_name = &quot;hello&quot;;
    p.m_age = 10;
    p.show();
}
</code></pre>
<h3 id="128-类模板与友元">1.2.8 类模板与友元</h3>
<ol>
<li>全局函数类内实现，只需要添加<code>friend</code>关键字</li>
</ol>
<pre><code class="language-c++">template&lt;typename T, typename U&gt;
class Person {
    // 全局函数，类内实现
    friend void show(Person&lt;T, U&gt; p) {
        cout &lt;&lt; &quot;name: &quot; &lt;&lt; p.m_name &lt;&lt; &quot;,age : &quot; &lt;&lt; p.m_age &lt;&lt; endl;
    }

public:
    Person(T t, U u) {
        this-&gt;m_name = t;
        this-&gt;m_age = u;
    }

private:
    T m_name;
    U m_age;
};

void test1() {
    Person&lt;string, int&gt; p(&quot;yoke&quot;, 12);
    show(p);
}

int main() {
    test1();
}
</code></pre>
<ol start="2">
<li>全局函数类外实现</li>
</ol>
<pre><code class="language-c++">template&lt;typename T, typename U&gt;
class Person;

template&lt;typename T, typename U&gt;
void show(Person&lt;T, U&gt; p) {
    cout &lt;&lt; &quot;name: &quot; &lt;&lt; p.m_name &lt;&lt; &quot;,age : &quot; &lt;&lt; p.m_age &lt;&lt; endl;
}

template&lt;typename T, typename U&gt;
class Person {
    // 全局函数，类内实现
    friend void show&lt;&gt;(Person&lt;T, U&gt; p); // 提示该方法是模板方法，需要加&lt;&gt;

public:
    Person(T t, U u) {
        this-&gt;m_name = t;
        this-&gt;m_age = u;
    }

private:
    T m_name;
    U m_age;
};


void test1() {
    Person&lt;string, int&gt; p(&quot;yoke&quot;, 12);
    show(p);
}

int main() {
    test1();
}
</code></pre>
<p>友元在类外实现相对复杂，所以通常使用类内实现</p>
<h1 id="2-stl">2. STL</h1>
<h2 id="21-stl基本概念">2.1 STL基本概念</h2>
<ul>
<li>STL(Standard Template Libray) 标准模板库</li>
<li>STL从广义上分为: 容器(container),算法(Algorithm),迭代器(Iterator)</li>
<li>容器和算法之间通过迭代器进行无缝连接</li>
<li>STL几乎所有的代码都采用类模板类或者模板函数</li>
</ul>
<h2 id="22-stl六大组件">2.2 STL六大组件</h2>
<p>六大组件：容器，算法，迭代器，仿函数，适配器，空间配置器</p>
<ol>
<li>容器：各种数据结构。<code>vector</code>,<code>list</code>,<code>deque</code>,<code>set</code>,<code>map</code>等用来存放数据</li>
<li>算法：各种常用的算法。<code>sort</code>,<code>find</code>,<code>copy</code>,<code>for_each</code>等</li>
<li>迭代器：扮演了容器和算法之间的胶合剂</li>
<li>仿函数：行为类似于函数，可作为算法的某种策略</li>
<li>适配器</li>
<li>空间配置器</li>
</ol>
<h2 id="23-容器算法迭代器初识">2.3 容器算法迭代器初识</h2>
<h3 id="231-vector-4种遍历">2.3.1 vector 4种遍历</h3>
<ol>
<li>使用迭代器进行遍历</li>
</ol>
<pre><code class="language-c++">//    vc.begin();
//    auto end = vc.end();
//    while (it != end) {
//        cout &lt;&lt; *it &lt;&lt; endl;
//        it++;
//    }
</code></pre>
<ol start="2">
<li>使用for循环进行访问</li>
</ol>
<pre><code class="language-c++">for (auto it = vc.begin(); it != vc.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; endl;
}
</code></pre>
<ol start="3">
<li>使用算法标准库</li>
</ol>
<p>直接使用<code>for_each</code>函数进行遍历。for_each的三个参数：迭代器开始，迭代器结束，执行的func。</p>
<pre><code class="language-c++">for_each(vc.begin(), vc.end(), myPrint);
// 函数的定义
void myPrint(int val) {
    cout &lt;&lt; val &lt;&lt; endl;
}
</code></pre>
<ol start="4">
<li>for循环</li>
</ol>
<pre><code class="language-c++">for (int &amp;cur: vc) {
        cout &lt;&lt; cur &lt;&lt; endl;
}
</code></pre>
<h2 id="24-常用容器">2.4 常用容器</h2>
<h3 id="241-string容器">2.4.1 string容器</h3>
<p>本质：string本质是c++中的一个类</p>
<p><strong>字符串赋值</strong></p>
<p>使用<code>=</code>or <code>assign()</code>进行赋值</p>
<p><strong>字符串拼接</strong></p>
<p>使用<code>+=</code>or<code>append()</code>进行字符串拼接</p>
<p><strong>字符串查找和替换</strong></p>
<p>使用<code>find()</code>or<code>rfind()</code>,<code>replace()</code>等方法实现</p>
<p><strong>字符串比较是否相等</strong></p>
<p>使用<code>compare()</code>按照ASII值进行对比</p>
<p><strong>字符串存取</strong></p>
<p>使用<code>[]</code>or <code>at()</code>进行取单个字符</p>
<p><strong>字符串插入和删除</strong></p>
<p>使用<code>insert()</code>,<code>earse()</code>对字符串进行删除</p>
<p><strong>字符串截取</strong></p>
<p>使用<code>substr()</code>进行字符串截取操作</p>
<h3 id="242-vector容器">2.4.2 vector容器</h3>
<p><strong>vector相关操作</strong></p>
<ol>
<li><code>push_back</code>:尾部插入</li>
<li><code>pop_back</code>:尾部删除</li>
<li><code>insert</code>: 在指定位置插入</li>
<li><code>erase</code>: 指定位置删除</li>
<li><code>clear</code>: 清空容器元素</li>
<li><code>at</code>返回指定索引的数据</li>
<li><code>[]</code>: 返回指定位置的数据</li>
<li><code>front</code>:返回容器第一个元素</li>
<li><code>back</code>: 返回容器最后一个元素</li>
<li><code>swap</code>: 数组交换 .<font color='red'>巧用swap可以收缩内存空间</font></li>
<li><code>reserver</code>: 为数据预留指定大小的内存空间。如果数据量较大，可以一开始利用<code>reserve</code>预留空间</li>
</ol>
<pre><code class="language-c++">int main() {
    vector&lt;int&gt; vc;
    // 插入10个数字
    for (int i = 0; i &lt; 10; i++) {
        vc.push_back(i);
    }
    vc.resize(3);
    vector&lt;int&gt;(vc).swap(vc);
    return 0;
}
</code></pre>
<h3 id="243-deque容器">2.4.3 deque容器</h3>
<p><strong>功能</strong><br>
双端数组，可以对头部和尾部进行插入，删除操作。本质是通过索引，将多块小的内存空间整合到一块来进行</p>
<h3 id="244-stack容器">2.4.4 stack容器</h3>
<p><strong>概念</strong><br>
stack是一种先进后出的数据结构，它只有一个出口</p>
<h3 id="245-queue容器">2.4.5 queue容器</h3>
<p>queue是一种先进先出的数据结构</p>
<h3 id="246-list容器">2.4.6 list容器</h3>
<p>list是将数据进行链式存储，是一个双向循环链表</p>
<h3 id="247-setmultiset容器">2.4.7 set/multiset容器</h3>
<p>所有元素在插入的时候都会进行排序。set/multiset属于关联容器，底层结构是二叉树实现的。<br>
<strong>set/multiset区别</strong></p>
<ul>
<li>set中元素是不允许重复</li>
<li>multiset中元素是允许重复</li>
</ul>
<p><strong>set一些常用操作</strong></p>
<ol>
<li><code>insert()</code>: 插入元素</li>
<li><code>erase()</code>: 删除元素</li>
</ol>
<p><strong>set容器自定义排序</strong></p>
<p>通过自定义仿函数，来自定义排序规则。仿函数本质就是个重载了<code>()</code>的类</p>
<pre><code class="language-c++">class MyCompare {
public:
    bool operator()(int a, int b) const {
        return a &gt; b;
    }
};
void mySort() {
    set&lt;int, MyCompare&gt; s;
    s.insert(10);
    s.insert(20);
    for (auto e: s) {
        cout &lt;&lt; e &lt;&lt; endl;
    }
}
</code></pre>
<p><strong>set存放自定义数据类型</strong><br>
<font color='red'>set在存放自定义数据类型时，必须传入排序方式，因为c++并不知道如何实现对自定义数据类型的排序</font></p>
<pre><code class="language-c++">class Person {
public:
    string m_name;
    int m_age;
    Person(string name, int age) : m_name(name), m_age(age) {}
};
// 使用仿函数进行数据排序
class MyComparator {
public:
    bool operator()(const Person &amp;p1, const Person &amp;p2) {
        return p1.m_age &gt; p2.m_age;
    }
};
void myPrint() {
    set&lt;Person, MyComparator&gt; s;
    s.insert(Person(&quot;yoke&quot;, 10));
    s.insert(Person(&quot;song&quot;, 200));
    for (const auto &amp;person: s) {
        cout &lt;&lt; &quot;name:&quot; &lt;&lt; person.m_name &lt;&lt; &quot;, age:&quot; &lt;&lt; person.m_age &lt;&lt; endl;
    }
}
int main() {
    myPrint();
    return 0;
}
</code></pre>
<h3 id="248-pair使用">2.4.8 pair使用</h3>
<p><strong>创建pair</strong></p>
<pre><code class="language-c++">// 构造传参数
 pair&lt;int, int&gt; p1(10, 20);
// 调用make_pair
 pair&lt;int, int&gt; p2 = make_pair(1, 2);
</code></pre>
<h3 id="249-mapmultimap容器">2.4.9 map/multimap容器</h3>
<p><strong>简介</strong><br>
map里面存放的都是<code>pair</code>元素，<code>pair</code>中的第一个元素为key,第二个元素为value。map底层存储数据采用的是二叉树进行存储。</p>
<ol>
<li>map与multimap区别:map中不允许存在相同的key,multimap中允许存在相同的key</li>
</ol>
<p><strong>基本使用</strong></p>
<pre><code class="language-c++">// 创建map实例
map&lt;string,int&gt; dict;
// 添加元素
dict.insert(pair&lt;string,int&gt;(&quot;yoke&quot;,10));
dict.insert(pair&lt;string,int&gt;(&quot;test&quot;,20));
// 打印输出元素
for(auto entry:dict){
    cout&lt;&lt;&quot;the first element is :&lt;&lt;entry.first&lt;&lt;&quot;,the second element is:&quot;&lt;&lt;entry.second&lt;&lt;endl;
}
</code></pre>
<p><strong>自定义排序</strong><br>
通过仿函数来自定义排序</p>
<pre><code class="language-c++">class MyCompare {
public:
    bool operator()(string k1, string k2) const {
        return k1.length() &gt; k2.length();
    }
};
int main() {
    map&lt;string, string, MyCompare&gt; m;
    m.insert(make_pair(&quot;hello&quot;, &quot;world222&quot;));
    return 0;
}
</code></pre>
<h2 id="25-函数对象">2.5 函数对象</h2>
<h3 id="251-函数基本使用">2.5.1 函数基本使用</h3>
<p><strong>概念</strong></p>
<ul>
<li>重载了类的<code>()</code>操作符的类，它的对象称为函数对象</li>
<li>函数对象使用重载的<code>()</code>时，行为类似于函数调用，因此又叫做<strong>仿函数</strong></li>
</ul>
<p><strong>本质</strong><br>
函数对象是一个类，不是一个函数</p>
<p><strong>使用</strong></p>
<ol>
<li>函数在使用的时候，可以像普通函数那样调用，可以有参数，可以有返回值</li>
</ol>
<pre><code class="language-c++">class SumFunction {
public:
    int operator()(int a, int b) const {
        return a + b;
    }
};
int main() {
    SumFunction sf;  // 创建仿函数对象
    int ans = sf(10, 20);  // 调用()方法
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
</code></pre>
<ol start="2">
<li>函数可以拥有自己的状态</li>
</ol>
<pre><code class="language-c++">
class SumFunction {
public:
    int count = 0;
    // 统计该方调用了多少次
    int operator()(const int a, const int b) {
        count++;
        return a + b;
    }
};
int main() {
    SumFunction sf;
    int ans = sf(10, 20);
    ans = sf(10, 20);
    cout &lt;&lt; ans &lt;&lt; endl;
    cout &lt;&lt; &quot;方法调用了&quot; &lt;&lt; sf.count &lt;&lt; endl;
    return 0;
}
</code></pre>
<ol start="3">
<li>函数可以作为参数进行传递</li>
</ol>
<pre><code class="language-c++">class SumFunction {
public:
    int count = 0;

    // 统计该方调用了多少次
    int operator()(const int a, const int b) {
        count++;
        return a + b;
    }
};

void test(SumFunction &amp;sf) {
    int ans = sf(10, 20);
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
    SumFunction sf;
    test(sf);
    return 0;
}
</code></pre>
<h3 id="252-谓词">2.5.2 谓词</h3>
<p><strong>谓词概念</strong></p>
<ul>
<li>返回bool类型的仿函数才是谓词</li>
<li>如果<code>operator()</code>接收一个参数，叫做一元谓词</li>
<li>如果<code>operator()</code>接收两个参数，叫做二元谓词</li>
</ul>
<p><strong>一元谓词使用</strong></p>
<pre><code class="language-c++">// 一元谓词
class MyCom {
public:
    bool operator()(int val) {
        return val &gt; 5;
    }
};
int main() {
    vector&lt;int&gt; v;
    for (int i = 0; i &lt; 7; i++) {
        v.push_back(i);
    }
    auto it = find_if(v.begin(), v.end(), MyCom());
    cout &lt;&lt; *it &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><strong>二元谓词使用</strong></p>
<pre><code class="language-c++">// 二元谓词使用
class MyCom {
public:
    bool operator()(const int val1, const int val2) {
        return val1 &gt; val2;
    }
};
int main() {
    vector&lt;int&gt; vc;
    vc.push_back(10);
    vc.push_back(2);
    vc.push_back(12);
    sort(vc.begin(), vc.end(), MyCom());
    for (auto e: vc) {
        cout &lt;&lt; e &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="253-内建函数对象">2.5.3 内建函数对象</h3>
<p>内建函数对象与一般的函数对象使用完全相同。使用的时候需要引入:<code>functional</code>头文件<br>
<strong>算术仿函数</strong></p>
<ul>
<li><code>template&lt;class T&gt; plus&lt;T&gt;</code>  // 加法仿函数</li>
<li><code>template&lt;class T&gt; minus&lt;T&gt;</code>  // 减法仿函数<br>
...<br>
<strong>关系运算符</strong></li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>    // 大于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>    // 小于<br>
...</li>
</ul>
<pre><code class="language-c++">int main() {
    vector&lt;int&gt; vc;
    vc.push_back(10);
    vc.push_back(2);
    sort(vc.begin(), vc.end(), greater&lt;int&gt;());   // 调用c++已有的内建函数类型
    for (auto e: vc) {
        cout &lt;&lt; e &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<h3 id="254-逻辑仿函数">2.5.4 逻辑仿函数</h3>
<p>可以实现逻辑运算</p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>   // 逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>  // 逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>   // 逻辑非</li>
</ul>
<h1 id="3-常用算法">3. 常用算法</h1>
<h2 id="31-常用遍历算法">3.1 常用遍历算法</h2>
<h3 id="311-for_each">3.1.1 for_each</h3>
<p><strong>功能描述</strong></p>
<p>对集合中的元素进行遍历操作</p>
<p><strong>函数原型</strong></p>
<pre><code class="language-c++">for_each(_InputIterator __first, _InputIterator __last, _Function __f)
__first:  集合起始迭代器位置
__last: 集合结束迭代器位置
__f: 要执行的操作，对应的仿函数
</code></pre>
<p><strong>例子</strong></p>
<pre><code class="language-c++">class MyPrint {
public:
    void operator()(int val) {
        cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; endl;
    }
};

void test() {
    vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 10; i++) {
        v1.push_back(i);
    }
    for_each(v1.begin(), v1.end(), MyPrint());
}

int main() {
    test();
    return 0;
}
</code></pre>
<h3 id="312-transform">3.1.2 transform</h3>
<p><strong>功能描述</strong><br>
搬运容器的数据到另外一个容器中去。<font color='red'>目标容器需要提前分配空间，不然会报错</font><br>
<strong>函数原型</strong><br>
<code>transform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op) </code></p>
<ol>
<li>__first: 源容器的起始迭代器</li>
<li>__last: 源容器的结束迭代器</li>
<li>__result: 目标容器的起始迭代器</li>
<li>__op:在复制过程中需要进行的操作，使用仿函数进行操作</li>
</ol>
<p><strong>例子</strong></p>
<pre><code class="language-c++">class MyOperation {
public:
    int operator()(int val) {
        return val + 1;
    }
};

class MyPrint {
public:
    void operator()(int val) {
        cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; endl;
    }
};

void test() {
    // 实现数据的搬运
    vector&lt;int&gt; v1;
    for (int i = 0; i &lt; 10; i++) {
        v1.push_back(i);
    }
    // 将数据搬运到v2中
    vector&lt;int&gt; v2(v1.size());  // 需要注意目标容器必须提前开辟空间，否则不能进行数据复制。
    transform(v1.begin(), v1.end(), v2.begin(), MyOperation());
    for_each(v2.begin(), v2.end(), MyPrint());
}
int main() {
    test();
    return 0;
}
</code></pre>
<h2 id="32-常用查找算法">3.2 常用查找算法</h2>
<h3 id="321-find">3.2.1 find</h3>
<p><strong>功能描述</strong><br>
在集合中查找某个元素，如果存在返回对应的迭代器，如果不存在，返回it.end()<br>
<strong>函数原型</strong><br>
<code>find(_InputIterator __first, _InputIterator __last, const _Tp&amp; __value_)</code></p>
<ol>
<li>__first: 容器起始迭代器</li>
<li>__last: 容器结束迭代器</li>
<li>__value: 查找的目标值</li>
</ol>
<p><strong>例子</strong></p>
<ol>
<li>常规数据查找</li>
</ol>
<pre><code class="language-c++">void test() {
    vector&lt;int&gt; vc;
    for (int i = 0; i &lt; 10; i++) {
        vc.push_back(i);
    }
    auto it = find(vc.begin(), vc.end(), 1);
    if(it==vc.end()){
    }
}
int main() {
    test();
    return 0;
}
</code></pre>
<ol start="2">
<li>自定义元素查找<br>
<strong>需要注意的地方</strong><br>
实现自定义数据查找，需要重写<code>==</code><br>
<strong>例子</strong></li>
</ol>
<pre><code class="language-c++">class Person {
public:
    string m_name;
    int m_age;

    Person(string name, int age) : m_name(name), m_age(age) {}

    bool operator==(const Person &amp;p) {
        return this-&gt;m_name == p.m_name &amp;&amp; this-&gt;m_age == p.m_age;
    }
};
int main() {
    vector&lt;Person&gt; v;
    v.push_back(Person(&quot;hello&quot;, 10));
    auto it = find(v.begin(), v.end(), Person(&quot;hello&quot;, 10));
    if (it != v.end()) {
        cout &lt;&lt; &quot;找到了元素&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;元素不存在&quot; &lt;&lt; endl;
    }
}
</code></pre>
<h3 id="322">3.2.2</h3>
<p><strong>功能描述</strong><br>
提供按条件查找的功能<br>
<strong>函数原型</strong></p>
<pre><code class="language-c++">find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred){}
</code></pre>
<ol>
<li>__first: 迭代器起始下标</li>
<li>__last:迭代器结束下标</li>
<li>__pred: 谓词<br>
<strong>例子</strong></li>
</ol>
<pre><code class="language-c++">class Person {
public:
    Person(string name, int age) : m_name(name), m_age(age) {}

    int m_age;
    string m_name;
};

//构造仿函数使用谓词
class Find_Person {
public:
    bool operator()(Person &amp;p) {
        return p.m_age &gt; 10;
    }
};

// 根据判断查找满足条件的自定义数据类型的数据
void test() {
    vector&lt;Person&gt; vc;
    vc.push_back(Person(&quot;yoke&quot;, 10));
    vc.push_back(Person(&quot;test&quot;, 20));
    vc.push_back(Person(&quot;fsd&quot;, 30));
    auto it = find_if(vc.begin(), vc.end(), Find_Person());
    if (it != vc.end()) {
        cout &lt;&lt; &quot;找到&quot; &lt;&lt; endl;
        Person &amp;p = *it;
        cout &lt;&lt; &quot;personName&quot; &lt;&lt; p.m_name &lt;&lt; &quot;, personAge:&quot; &lt;&lt; p.m_age &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;没有找到&quot; &lt;&lt; endl;
    }
}

int main() {
    test();
    return 0;
}
</code></pre>
<h3 id="323-adjacent_find">3.2.3 adjacent_find</h3>
<p><strong>功能描述</strong><br>
查找相邻重复元素<br>
<strong>函数原型</strong></p>
<pre><code class="language-c++">adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
</code></pre>
<ol>
<li>__first: 迭代器起始位置</li>
<li>__last: 迭代器结束位置</li>
</ol>
<h3 id="324-binary_search">3.2.4 binary_search</h3>
<p><strong>功能描述</strong><br>
针对集合中的元素进行二分查找<br>
<strong>函数原型</strong></p>
<pre><code class="language-c++">binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp&amp; __value_)
</code></pre>
<p><strong>注意</strong></p>
<ol>
<li>返回值是<code>bool</code></li>
<li>被查找的集合必须是有序的</li>
</ol>
<h3 id="325-count">3.2.5 count</h3>
<p><strong>功能描述</strong><br>
统计集合中某个元素的个数<br>
<strong>函数原型</strong></p>
<pre><code class="language-c++">count(_InputIterator __first, _InputIterator __last, const _Tp&amp; __value_)
</code></pre>
<ol>
<li>value: 待查找元素的值</li>
</ol>
<h3 id="326-count_if">3.2.6 count_if</h3>
<p><strong>功能描述</strong><br>
根据条件统计元素个数</p>
<h2 id="33-常用排序算法">3.3 常用排序算法</h2>
<p>常用的排序算法有以下4种</p>
<ol>
<li><code>sort</code>: 对容器中的元素进行排序</li>
<li><code>random_shuffle</code>: 指定范围内的元素随即调整次序</li>
<li><code>merge</code>: 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>: 反转指定范围的元素</li>
</ol>
<h3 id="331-sort函数的使用">3.3.1 sort函数的使用</h3>
<p>sort默认是升序排序，通过指定谓词实现自定义排序</p>
<pre><code class="language-c++"> sort(vc.begin(), vc.end(), greater&lt;int&gt;());
</code></pre>
<p>通过使用<code>greater&lt;&gt;()</code>谓词来实现从大到小排序</p>
<h3 id="332-random_shuffle">3.3.2 random_shuffle</h3>
<p><strong>功能描述</strong><br>
打乱指定范围内的元素</p>
<h3 id="333-merge">3.3.3 merge</h3>
<p><strong>功能描述</strong><br>
将两个有序的集合，进行归并排序，最后合并成一个有序集合</p>
<h3 id="334-reverse">3.3.4 reverse</h3>
<p><strong>功能描述</strong><br>
将集合中的元素进行反转</p>
<h2 id="34-常用拷贝和替换算法">3.4 常用拷贝和替换算法</h2>
<p>常用的有以下4种</p>
<ol>
<li><code>copy</code>: 将容器中指定内容拷贝到另外一个容器中</li>
<li><code>replace</code>: 将容器内指定的旧元素修改为新的元素</li>
<li><code>replace_if</code>:根据提交将旧元素替换成新的元素</li>
<li><code>swap</code>: 互换两个容器中的元素</li>
</ol>
<h2 id="35-常用的算术生成算法">3.5 常用的算术生成算法</h2>
<p>常用的算术生成算法有</p>
<ol>
<li><code>accumulate</code>: 计算容器中元素的总和</li>
<li><code>fill</code>: 向容器中添加元素<br>
<font color='red'>在使用这些算法之前，需要引入<code>numeric</code></font></li>
</ol>
<h2 id="36-常用集合算法">3.6 常用集合算法</h2>
<p>常用的集合算法有</p>
<ol>
<li><code>set_intersection</code>: 求两个容器的交集</li>
<li><code>set_union</code>: 求两个容器的并集</li>
<li><code>set_difference</code>: 求两个容器的差集</li>
</ol>
 </p>
                    </div>
                </div>

                <div class="row">
                    <div class="col-md-12 animate-box">
                        
                            <div class="next-post">
                                <div class="next">下一篇</div>
                                <a href="https://saseke.github.io/post/defining-cloud-computing/">
                                    <h3 class="post-title">
                                        Defining Cloud Computing
                                    </h3>
                                </a>
                            </div>
                        
                    </div>
                </div>

                <div class="row">
    <div class="col-md-12 animate-box">
        
    </div>
</div>

            </div>

        </article>
    </div>
</div>

    

    <!-- 返回顶部 -->
    <div class="back-to-top">
    
        <a href="#!" id="tool-toc" class="hidden-xs hidden-sm">
            <i class="fa fa-map"></i>
        </a>
        <br>
    
    <a href="#top" class="hidden-xs hidden-sm"><i class="fa fa-paper-plane"></i></a>
</div>

<div class="post-toc animated fadeInRight hidden-xs hidden-sm" style="display: none;">
    <ul class="markdownIt-TOC">
<li><a href="#1-%E6%A8%A1%E6%9D%BF">1. 模板</a>
<ul>
<li><a href="#11-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF">1.1 函数模板</a>
<ul>
<li><a href="#111%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89">1.1.1模板定义</a></li>
<li><a href="#112-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB">1.1.2 普通函数与函数模板区别</a></li>
<li><a href="#113-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99">1.1.3 普通函数与函数模板调用规则</a></li>
<li><a href="#114-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7">1.1.4 模板的局限性</a></li>
</ul>
</li>
<li><a href="#12-%E7%B1%BB%E6%A8%A1%E7%89%88">1.2 类模版</a>
<ul>
<li><a href="#121-%E7%B1%BB%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95">1.2.1 类模版语法</a></li>
<li><a href="#122-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%8C%BA%E5%88%AB">1.2.2 类模板与函数模板区别</a></li>
<li><a href="#123-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA">1.2.3 类模板中成员函数创建时机</a></li>
<li><a href="#124-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AF%B9%E8%B1%A1%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">1.2.4 类模板对象做函数参数</a></li>
<li><a href="#125-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%BB%A7%E6%89%BF">1.2.5 类模板与继承</a></li>
<li><a href="#126-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0">1.2.6 类模板的成员函数的类外实现</a></li>
<li><a href="#127-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6%E5%88%86%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99">1.2.7 类模板文件分模块编写</a></li>
<li><a href="#128-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%8F%8B%E5%85%83">1.2.8 类模板与友元</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-stl">2. STL</a>
<ul>
<li><a href="#21-stl%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">2.1 STL基本概念</a></li>
<li><a href="#22-stl%E5%85%AD%E5%A4%A7%E7%BB%84%E4%BB%B6">2.2 STL六大组件</a></li>
<li><a href="#23-%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E8%AF%86">2.3 容器算法迭代器初识</a>
<ul>
<li><a href="#231-vector-4%E7%A7%8D%E9%81%8D%E5%8E%86">2.3.1 vector 4种遍历</a></li>
</ul>
</li>
<li><a href="#24-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8">2.4 常用容器</a>
<ul>
<li><a href="#241-string%E5%AE%B9%E5%99%A8">2.4.1 string容器</a></li>
<li><a href="#242-vector%E5%AE%B9%E5%99%A8">2.4.2 vector容器</a></li>
<li><a href="#243-deque%E5%AE%B9%E5%99%A8">2.4.3 deque容器</a></li>
<li><a href="#244-stack%E5%AE%B9%E5%99%A8">2.4.4 stack容器</a></li>
<li><a href="#245-queue%E5%AE%B9%E5%99%A8">2.4.5 queue容器</a></li>
<li><a href="#246-list%E5%AE%B9%E5%99%A8">2.4.6 list容器</a></li>
<li><a href="#247-setmultiset%E5%AE%B9%E5%99%A8">2.4.7 set/multiset容器</a></li>
<li><a href="#248-pair%E4%BD%BF%E7%94%A8">2.4.8 pair使用</a></li>
<li><a href="#249-mapmultimap%E5%AE%B9%E5%99%A8">2.4.9 map/multimap容器</a></li>
</ul>
</li>
<li><a href="#25-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">2.5 函数对象</a>
<ul>
<li><a href="#251-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2.5.1 函数基本使用</a></li>
<li><a href="#252-%E8%B0%93%E8%AF%8D">2.5.2 谓词</a></li>
<li><a href="#253-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">2.5.3 内建函数对象</a></li>
<li><a href="#254-%E9%80%BB%E8%BE%91%E4%BB%BF%E5%87%BD%E6%95%B0">2.5.4 逻辑仿函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95">3. 常用算法</a>
<ul>
<li><a href="#31-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">3.1 常用遍历算法</a>
<ul>
<li><a href="#311-for_each">3.1.1 for_each</a></li>
<li><a href="#312-transform">3.1.2 transform</a></li>
</ul>
</li>
<li><a href="#32-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">3.2 常用查找算法</a>
<ul>
<li><a href="#321-find">3.2.1 find</a></li>
<li><a href="#322">3.2.2</a></li>
<li><a href="#323-adjacent_find">3.2.3 adjacent_find</a></li>
<li><a href="#324-binary_search">3.2.4 binary_search</a></li>
<li><a href="#325-count">3.2.5 count</a></li>
<li><a href="#326-count_if">3.2.6 count_if</a></li>
</ul>
</li>
<li><a href="#33-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">3.3 常用排序算法</a>
<ul>
<li><a href="#331-sort%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8">3.3.1 sort函数的使用</a></li>
<li><a href="#332-random_shuffle">3.3.2 random_shuffle</a></li>
<li><a href="#333-merge">3.3.3 merge</a></li>
<li><a href="#334-reverse">3.3.4 reverse</a></li>
</ul>
</li>
<li><a href="#34-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95">3.4 常用拷贝和替换算法</a></li>
<li><a href="#35-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95">3.5 常用的算术生成算法</a></li>
<li><a href="#36-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95">3.6 常用集合算法</a></li>
</ul>
</li>
</ul>

</div>


    
<footer id="fh5co-footer">
  <p>Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></p>
</footer>


    <!-- jQuery -->
<script src="https://saseke.github.io/media/scripts/jquery.min.js"></script>
<!-- img lazy load -->
<script src="https://saseke.github.io/media/scripts/jquery.lazyload.min.js"></script>
<!-- jQuery Easing -->
<script src="https://saseke.github.io/media/scripts/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="https://saseke.github.io/media/scripts/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="https://saseke.github.io/media/scripts/jquery.waypoints.min.js"></script>
<!-- Main JS -->
<script src="https://saseke.github.io/media/scripts/main.js"></script>
<!-- Md5 Min JS -->
<script src="https://saseke.github.io/media/scripts/md5.min.js"></script>
<!-- katex -->
<!--<script src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js"></script>-->
<!-- highlight -->
<script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>


<script type="application/javascript">
    // 代码高亮
    hljs.initHighlightingOnLoad();

    // img 懒加载
    $(function () {
        $("img.lazy").lazyload({
            effect: "fadeIn",  // 懒加载动画
            threshold: 180  // 在图片距离屏幕180px时提前载入
        });
        // tooltip
        $('[data-toggle="tooltip"]').tooltip();

        // 目录
        $('#tool-toc').click(function () {
            $('.post-toc').toggle();
        });
    });

    
</script>




</body>
</html>
